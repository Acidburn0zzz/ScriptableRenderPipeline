
#pragma kernel NoFilterWithoutDynShadows     CSMain=NoFilterWithoutDynShadows     NO_FILTERING
#pragma kernel BiLinearWithoutDynShadows     CSMain=BiLinearWithoutDynShadows     BI_LINEAR
#pragma kernel TriLinearWithoutDynShadows    CSMain=TriLinearWithoutDynShadows    TRI_LINEAR
//#pragma kernel PCF9x9LinearWithoutDynShadows CSMain=PCF9x9LinearWithoutDynShadows PCF9x9_FILTERING

#pragma kernel NoFilterWithDynShadows        CSMain=NoFilterWithDynShadows        WITH_DYNAMIC_SHADOWS NO_FILTERING
#pragma kernel BiLinearWithDynShadows        CSMain=BiLinearWithDynShadows        WITH_DYNAMIC_SHADOWS BI_LINEAR
#pragma kernel TriLinearWithDynShadows       CSMain=TriLinearWithDynShadows       WITH_DYNAMIC_SHADOWS TRI_LINEAR
//#pragma kernel PCF9x9LinearWithDynShadows    CSMain=PCF9x9LinearWithDynShadows    WITH_DYNAMIC_SHADOWS PCF9x9_FILTERING

#define TILE_SIZE 8

#define _SHADOWS_ENABLED
#ifdef PCF9x9_FILTERING
#define _SHADOWS_SOFT
#endif

#define USE_EMULATE_CLZ
//#define USE_IMITATED_CLS


#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Input.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl"

#ifdef UNITY_MATRIX_I_VP
#undef UNITY_MATRIX_I_VP
#endif


#define UNITY_MATRIX_I_VP _InvViewProjMatrix

#if defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
TEXTURE2D_ARRAY_FLOAT(_CameraDepthTexture);
#else
TEXTURE2D_FLOAT(_CameraDepthTexture);
#endif

SAMPLER(sampler_CameraDepthTexture);

CBUFFER_START(DirectionalVxShadowMap)
uint _VoxelResolution;
uint _VoxelBias;
uint _MaxScale;
float4x4 _WorldToShadowMatrix;
CBUFFER_END

StructuredBuffer<uint> _VxShadowMapBuffer;
RW_TEXTURE2D(float, _ScreenSpaceShadowOutput);


uint emulateCLZ(uint x)
{
    // emulate it similar to count leading zero.
    // count leading 1bit.

    uint n = 32;
    uint y;

    y = x >> 16; if (y != 0) { n = n - 16; x = y; }
    y = x >>  8; if (y != 0) { n = n -  8; x = y; }
    y = x >>  4; if (y != 0) { n = n -  4; x = y; }
    y = x >>  2; if (y != 0) { n = n -  2; x = y; }
    y = x >>  1; if (y != 0) return n - 2;

    return n - x;
}


uint CalculateMismatchScale(uint scale, uint srcPosbit, uint dstPosbit)
{
#if defined USE_EMULATE_CLZ
    uint disparity = 32 - emulateCLZ(srcPosbit ^ dstPosbit);
#elif defined USE_IMITATED_CLS
    int i = _MaxScale;
    for (; i > 3; --i)
    {
        uint shift = i - 1;
    
        uint a = (srcPosbit >> shift) & 0x00000001;
        uint b = (dstPosbit >> shift) & 0x00000001;
    
        if (a != b)
            break;
    }
    uint disparity = i;
#else
    uint disparity = _MaxScale;
#endif

    return max(scale, disparity);
}


uint CalculateRetraversalScale(uint srcPosbit, uint dstPosbit)
{
#if defined USE_EMULATE_CLZ
    uint disparity = 32 - emulateCLZ(srcPosbit ^ dstPosbit);
#elif defined USE_IMITATED_CLS
    int i = _MaxScale;
    for (; i > 3; --i)
    {
        uint shift = i - 1;
    
        uint a = (srcPosbit >> shift) & 0x00000001;
        uint b = (dstPosbit >> shift) & 0x00000001;
    
        if (a != b)
            break;
    }
    uint disparity = i;
#else
    uint disparity = _MaxScale;
#endif

    return disparity;//max(_MaxScale, disparity);
}


uint4 TraverseVxShadowMapPosQ(uint3 posQ)
{
    uint nodeIndex = 0;
    uint scale = _MaxScale;

    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countbits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    return uint4(nodeIndex, lit, shadowed, intersected);
}


uint4 TraverseVxShadowMapPosQ(uint3 posQ, out uint scale, out uint nodeTracer[16])
{
    uint nodeIndex = 0;

    scale = _MaxScale;

    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // push node index
        uint tracerIndex = scale - 4;
        nodeTracer[tracerIndex] = nodeIndex;

        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countbits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    return uint4(nodeIndex, lit, shadowed, intersected);
}


uint4 TraverseVxShadowMapPosQ(uint3 posQ, uint scale, uint nodeIndex)
{
    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countbits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    return uint4(nodeIndex, lit, shadowed, intersected);
}


uint2 TraverseVxShadowMapLeaf(uint posQ_z, uint4 innerResult)
{
    uint nodeIndex   = innerResult.x;

    bool lit         = innerResult.y;
    bool intersected = innerResult.w;

    uint bitmask0 = lit ? 0x00000000 : 0xFFFFFFFF;
    uint bitmask1 = lit ? 0x00000000 : 0xFFFFFFFF;

    if (intersected)
    {
        int childIndex = posQ_z % 8;
        int leafIndex = _VxShadowMapBuffer[nodeIndex + childIndex];

        bitmask0 = _VxShadowMapBuffer[leafIndex];
        bitmask1 = _VxShadowMapBuffer[leafIndex + 1];
    }

    return uint2(bitmask0, bitmask1);
}


float PointSampleShadowBitmask(uint2 bitmask2, uint3 posQ)
{
    uint2 posLeaf = posQ.xy % uint2(8, 8);
    uint bitmask = posLeaf.y < 4 ? bitmask2.x : bitmask2.y;

    uint shift = posLeaf.x + 8 * (posLeaf.y % 4);
    uint mask = 0x00000001 << shift;

    float litRate = (bitmask & mask) == 0 ? 1.0 : 0.0;

    return litRate;
}


float PointSampleShadowBitmask(uint2 bitmask2, uint3 posQ, uint2 offset)
{
    uint2 posLeaf = (posQ.xy + offset) % uint2(8, 8);
    uint bitmask = posLeaf.y < 4 ? bitmask2.x : bitmask2.y;

    uint shift = posLeaf.x + 8 * (posLeaf.y % 4);
    uint mask = 0x00000001 << shift;

    float litRate = (bitmask & mask) == 0 ? 1.0 : 0.0;

    return litRate;
}


float ComputeVxShadowMapAttenuationNoFiltering(float3 positionWS)
{
    float3 posLS = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    bool lessThanBounds = any(posLS.xy < float2(0.0, 0.0));
    bool greaterThanBounds = any(posLS.xy > float2(1.0, 1.0));
    if (lessThanBounds || greaterThanBounds)
        return 1.0;

    float3 posP = posLS * (float)_VoxelResolution;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelBias;

    if (posQ.z < 0 || posQ.z >= _VoxelResolution)
        return 1.0;

    uint4 result = TraverseVxShadowMapPosQ(posQ);
    if (result.w == 0)
        return result.y ? 1.0 : 0.0;

    uint2 bitmask2 = TraverseVxShadowMapLeaf(posQ.z, result);
    float attenuation = PointSampleShadowBitmask(bitmask2, posQ);

    return attenuation;
}


float ComputeVxShadowMapAttenuationBiFiltering(float3 positionWS)
{
    float3 posLS = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    bool lessThanBounds = any(posLS.xy < float2(0.0, 0.0));
    bool greaterThanBounds = any(posLS.xy > float2(1.0, 1.0));
    if (lessThanBounds || greaterThanBounds)
        return 1.0;

    float3 posP = posLS * (float)_VoxelResolution - 0.5;
    float3 posF = floor(posP);
    float2 lerpWeight = posP.xy - posF.xy;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelBias;

    if (posQ.z < 0 || posQ.z >= _VoxelResolution)
        return 1.0;

    uint scale = 0;
    uint nodeTracer[16];

    uint4 result = TraverseVxShadowMapPosQ(posQ, scale, nodeTracer);
    // todo : early return by non-intersection
    //if (result.w == 0)
        //return result.y ? 1.0 : 0.0;

    //uint2 mismatchScale = uint2(
    //    CalculateMismatchScale(scale, posQ.x, posQ.x + 1),
    //    CalculateMismatchScale(scale, posQ.y, posQ.y + 1));
    uint2 retraversalScale = uint2(
        CalculateRetraversalScale(posQ.x, posQ.x + 1),
        CalculateRetraversalScale(posQ.y, posQ.y + 1));

    uint2 bitmask2_000 = TraverseVxShadowMapLeaf(posQ.z, result);
    uint2 bitmask2_100 = bitmask2_000;
    uint2 bitmask2_010 = bitmask2_000;
    uint2 bitmask2_110 = bitmask2_000;

    if (retraversalScale.x > scale)
    {
        uint nodeIndex = nodeTracer[retraversalScale.x - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(1, 0, 0), retraversalScale.x, nodeIndex);
        bitmask2_100 = TraverseVxShadowMapLeaf(posQ.z, result);
    }
    if (retraversalScale.y > scale)
    {
        uint nodeIndex = nodeTracer[retraversalScale.y - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(0, 1, 0), retraversalScale.y, nodeIndex);
        bitmask2_010 = TraverseVxShadowMapLeaf(posQ.z, result);
    }
    if (retraversalScale.x > scale || retraversalScale.y > scale)
    {
        uint retraversalScalexy = max(retraversalScale.x, retraversalScale.y);
        uint nodeIndex = nodeTracer[retraversalScalexy - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(1, 1, 0), retraversalScalexy, nodeIndex);
        bitmask2_110 = TraverseVxShadowMapLeaf(posQ.z, result);
    }

    float attenuation0 = PointSampleShadowBitmask(bitmask2_000, posQ);
    float attenuation1 = PointSampleShadowBitmask(bitmask2_100, posQ, uint3(1, 0, 0));
    float attenuation2 = PointSampleShadowBitmask(bitmask2_010, posQ, uint3(0, 1, 0));
    float attenuation3 = PointSampleShadowBitmask(bitmask2_110, posQ, uint3(1, 1, 0));

    //attenuation0 = lerp(attenuation0, attenuation1, lerpWeight.x);
    //attenuation1 = lerp(attenuation2, attenuation3, lerpWeight.x);

    float attenuation = lerp(attenuation0, attenuation1, lerpWeight.y);

    return attenuation1;
}


float ComputeVxShadowMapAttenuationTriFiltering(float3 positionWS)
{
    float3 posLS = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    bool lessThanBounds = any(posLS.xy < float2(0.0, 0.0));
    bool greaterThanBounds = any(posLS.xy > float2(1.0, 1.0));
    if (lessThanBounds || greaterThanBounds)
        return 1.0;

    float3 posP = posLS * (float)_VoxelResolution - 0.5;
    float3 posF = floor(posP);
    float3 lerpWeight = posP - posF;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelBias;

    if (posQ.z < 0 || posQ.z >= _VoxelResolution)
        return 1.0;

    uint scale = 0;
    uint nodeTracer[16];

    uint4 result = TraverseVxShadowMapPosQ(posQ, scale, nodeTracer);
    // todo : early return by non-intersection between z and z+1
    //if (result.w == 0)
        //return result.y ? 1.0 : 0.0;

    uint3 mismatchScale = uint3(
        CalculateMismatchScale(scale, posQ.x, posQ.x + 1),
        CalculateMismatchScale(scale, posQ.y, posQ.y + 1),
        CalculateMismatchScale(scale, posQ.z, posQ.z + 1));

    uint2 bitmask2_00 = TraverseVxShadowMapLeaf(posQ.z, result);
    uint2 bitmask2_10 = bitmask2_00;
    uint2 bitmask2_01 = bitmask2_00;
    uint2 bitmask2_11 = bitmask2_00;

    if (mismatchScale.x > scale)
    {
        uint nodeIndex = nodeTracer[mismatchScale.x - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(1, 0, 0), mismatchScale.x, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(1, 0, 0));
        bitmask2_10 = TraverseVxShadowMapLeaf(posQ.z, result);
    }
    if (mismatchScale.y > scale)
    {
        uint nodeIndex = nodeTracer[mismatchScale.y - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(0, 1, 0), mismatchScale.y, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(0, 1, 0));
        bitmask2_01 = TraverseVxShadowMapLeaf(posQ.z, result);
    }
    if (mismatchScale.x > scale || mismatchScale.y > scale)
    {
        uint mismatchScalexy = max(mismatchScale.x, mismatchScale.y);
        uint nodeIndex = nodeTracer[mismatchScalexy - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(1, 1, 0), mismatchScalexy, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(1, 1, 0));
        bitmask2_11 = TraverseVxShadowMapLeaf(posQ.z, result);
    }

    float attenuation0 = PointSampleShadowBitmask(bitmask2_00, posQ);
    float attenuation1 = PointSampleShadowBitmask(bitmask2_10, posQ, uint3(1, 0, 0));
    float attenuation2 = PointSampleShadowBitmask(bitmask2_01, posQ, uint3(0, 1, 0));
    float attenuation3 = PointSampleShadowBitmask(bitmask2_11, posQ, uint3(1, 1, 0));

    attenuation0 = lerp(attenuation0, attenuation1, lerpWeight.x);
    attenuation1 = lerp(attenuation2, attenuation3, lerpWeight.x);

    float attenuation_z0 = lerp(attenuation0, attenuation1, lerpWeight.y);

    if (mismatchScale.z > scale)
    {
        uint nodeIndex = nodeTracer[mismatchScale.z - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(0, 0, 1), mismatchScale.z, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(0, 0, 1));
    }

    bitmask2_00 = TraverseVxShadowMapLeaf(posQ.z + 1, result);
    bitmask2_10 = bitmask2_00;
    bitmask2_01 = bitmask2_00;
    bitmask2_11 = bitmask2_00;

    if (mismatchScale.x > scale)
    {
        uint nodeIndex = nodeTracer[mismatchScale.x - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(1, 0, 1), mismatchScale.x, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(1, 0, 1));
        bitmask2_10 = TraverseVxShadowMapLeaf(posQ.z + 1, result);
    }
    if (mismatchScale.y > scale)
    {
        uint nodeIndex = nodeTracer[mismatchScale.y - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(0, 1, 1), mismatchScale.y, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(0, 1, 1));
        bitmask2_01 = TraverseVxShadowMapLeaf(posQ.z + 1, result);
    }
    if (mismatchScale.x > scale || mismatchScale.y > scale)
    {
        uint mismatchScalexy = max(mismatchScale.x, mismatchScale.y);
        uint nodeIndex = nodeTracer[mismatchScalexy - 4];
        result = TraverseVxShadowMapPosQ(posQ + uint3(1, 1, 1), mismatchScalexy, nodeIndex);
        //result = TraverseVxShadowMapPosQ(posQ + uint3(1, 1, 1));
        bitmask2_11 = TraverseVxShadowMapLeaf(posQ.z + 1, result);
    }

    attenuation0 = PointSampleShadowBitmask(bitmask2_00, posQ);
    attenuation1 = PointSampleShadowBitmask(bitmask2_10, posQ, uint3(1, 0, 0));
    attenuation2 = PointSampleShadowBitmask(bitmask2_01, posQ, uint3(0, 1, 0));
    attenuation3 = PointSampleShadowBitmask(bitmask2_11, posQ, uint3(1, 1, 0));

    attenuation0 = lerp(attenuation0, attenuation1, lerpWeight.x);
    attenuation1 = lerp(attenuation2, attenuation3, lerpWeight.x);

    float attenuation_z1 = lerp(attenuation0, attenuation1, lerpWeight.y);

    float attenuation = lerp(attenuation_z0, attenuation_z1, lerpWeight.z);

    return attenuation0;
}


float ComputeVxShadowMapAttenuationPCF9x9iltering(float3 positionWS)
{
    float3 posLS = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    bool lessThanBounds = any(posLS.xy < float2(0.0, 0.0));
    bool greaterThanBounds = any(posLS.xy > float2(1.0, 1.0));
    if (lessThanBounds || greaterThanBounds)
        return 1.0;

    float3 posP = posLS * (float)_VoxelResolution;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelBias;

    if (posQ.z < 0 || posQ.z >= _VoxelResolution)
        return 1.0;

    uint4 result = TraverseVxShadowMapPosQ(posQ);
    if (result.w == 0)
        return result.y ? 1.0 : 0.0;

    uint2 bitmask2 = TraverseVxShadowMapLeaf(posQ.z, result);
    float attenuation = PointSampleShadowBitmask(bitmask2, posQ);

    return attenuation;
}

float SampleVxShadowmap(float3 positionWS)
{
    float attenuation = 1.0;

#if NO_FILTERING
    attenuation = ComputeVxShadowMapAttenuationNoFiltering(positionWS);
#elif BI_LINEAR
    attenuation = ComputeVxShadowMapAttenuationBiFiltering(positionWS);
    //attenuation = ComputeVxShadowMapAttenuationTriFiltering(positionWS);
#elif TRI_LINEAR
    attenuation = ComputeVxShadowMapAttenuationTriFiltering(positionWS);
#elif PCF9X9_FILTERING
    //attenuation = ComputeVxShadowMapAttenuationPCF9x9iltering(positionWS);
#endif

    return attenuation;
}


[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void CSMain(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    uint2 pixelCoord = groupId * TILE_SIZE + groupThreadId;
    uint2 tileCoord = groupId;

    if (any(pixelCoord.xy >= (uint2)_ScreenSize.xy))
        return;

    float depth = LOAD_TEXTURE2D(_CameraDepthTexture, pixelCoord).x;

    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _ScreenSpaceShadowOutput[pixelCoord] = 1.0;
        return;
    }

    // if depth is not reversed
#if !UNITY_REVERSED_Z
    // todo : find the way to work on OpenGLES 3.1+ on mobile
    //depth = depth * 2.0 - 1.0; OpenGLCore
#endif

#if 0
    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, tileCoord);
    float3 positionWS = posInput.positionWS;
#else
    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, tileCoord);
    float3 positionWS = ComputeWorldSpacePosition(posInput.positionNDC, depth, UNITY_MATRIX_I_VP);
#endif

#if WITH_DYNAMIC_SHADOWS
    float4 shadowMapCoords = TransformWorldToShadowCoord(positionWS);

    ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
    float shadowStrength = 1.0;//GetMainLightShadowStrength();
    float attenuation0 = SampleShadowmap(shadowMapCoords, TEXTURE2D_PARAM(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), shadowSamplingData, shadowStrength, false);

    float attenuation1 = 1.0;
    if (attenuation0 > 0.0)
        attenuation1 = SampleVxShadowmap(positionWS);

    float attenuation = min(attenuation0, attenuation1);
#else
    float attenuation = SampleVxShadowmap(positionWS);
#endif

    _ScreenSpaceShadowOutput[pixelCoord] = attenuation;
}
