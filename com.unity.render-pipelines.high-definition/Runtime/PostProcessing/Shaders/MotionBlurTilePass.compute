#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

#pragma kernel TileGenPass
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _TileMinMaxVel;
TEXTURE2D(_CameraMotionVectorsTexture);

#define TILE_SIZE                   16u
#define WAVE_SIZE					64u

#ifdef SUPPORTS_WAVE_INTRINSICS
groupshared float2 gs_minVel[((TILE_SIZE * TILE_SIZE) / WAVE_SIZE) + 1];
groupshared float2 gs_maxVel[((TILE_SIZE * TILE_SIZE) / WAVE_SIZE) + 1];


uint PackVelLengthAndLaneID(float len, uint ID)
{
	uint retVal = asuint(len) << 24;
	return retVal | ID;	
}

uint GetIDFromPacked(uint val)
{
	return val | 0xf;
}


#else
groupshared float2 gs_minVel[((TILE_SIZE * TILE_SIZE))];
groupshared float2 gs_maxVel[((TILE_SIZE * TILE_SIZE))];

#endif

float2 MinVec(float2 v, float2 w)
{
	return dot(v, v) < dot(w, w) ? v : w;
}

float2 MaxVec(float2 v, float2 w)
{
	return dot(v, v) < dot(w, w) ? w : v;
}

// TODO_FCC: Do dispatch indirect for the fast pass. 

[numthreads(TILE_SIZE, TILE_SIZE,1)]
void TileGenPass(uint3 id : SV_DispatchThreadID, uint gid : SV_GroupIndex, uint2 groupThreadId : SV_GroupThreadID)
{

//    // TODO_FCC: put min on ID when loading
//
//    // This works only with multiple of 8 for TILE_SIZE
#ifdef SUPPORTS_WAVE_INTRINSICS
    uint waveCount = ((TILE_SIZE * TILE_SIZE) / WAVE_SIZE) + 1;

	// This is a bit clunky... over complicated, but I am now curious.

	float2 vel = LOAD_TEXTURE2D(_CameraMotionVectorsTexture, id.xy).xy;
	float velLength = dot(vel, vel);
	uint laneIdx = WaveGetLaneIndex();
	uint PackedVelID = PackVelLengthAndLaneID(velLength, laneIdx);

	uint waveVelMin = WaveActiveMin(PackedVelID);
	uint waveVelMax = WaveActiveMax(PackedVelID);

	uint waveMinID = GetIDFromPacked(waveVelMin);
	uint waveMaxID = GetIDFromPacked(waveVelMax);

	// Only one per wave guaranteed. 
	uint waveIDInGroup = gid / WAVE_SIZE;
	if (waveMinID == laneIdx)
	{
		gs_minVel[waveIDInGroup] = vel;
	}
	if (waveMaxID == laneIdx)
	{
		gs_maxVel[waveIDInGroup] = vel;
	}


	// We have values for all the waves, let's sync. 
	GroupMemoryBarrierWithGroupSync();

	// Reduction across waves.
	// TODO_FCC Verify this is all scalar.
	float2 minVel = gs_minVel[0];
	float2 maxVel = gs_maxVel[0];
	for (int i = 1; i < waveCount; ++i)
	{
		minVel = MinVec(minVel, gs_minVel[i]);
		maxVel = MaxVec(maxVel, gs_maxVel[i]);
	}

    _TileMinMaxVel[id.xy] = float4(minVel.x, minVel.y, maxVel.x, maxVel.y);
#else
    uint threadIdx = groupThreadId.y * TILE_SIZE + groupThreadId.x;

    // TODO_FCC put this parallel reduction in common file.
    float2 vel = LOAD_TEXTURE2D(_CameraMotionVectorsTexture, id.xy).xy;

    gs_minVel[threadIdx] = vel;
    gs_maxVel[threadIdx] = vel;

    GroupMemoryBarrierWithGroupSync();

    // Parallel reduction - find the max/min value for this tile
    UNITY_UNROLL
    for (uint s = (TILE_SIZE * TILE_SIZE) / 2u; s > 0u; s >>= 1u)
    {
        if (threadIdx < s)
        {
            gs_minVel[threadIdx] = MinVec(gs_minVel[threadIdx], gs_minVel[threadIdx + s]);
            gs_maxVel[threadIdx] = MaxVec(gs_maxVel[threadIdx], gs_maxVel[threadIdx + s]);
        }

        GroupMemoryBarrierWithGroupSync();
    }

    float2 minVel = gs_minVel[0];
    float2 maxVel = gs_maxVel[0];
    _TileMinMaxVel[id.xy] = float4(minVel.x, minVel.y, maxVel.x, maxVel.y);
#endif

}
