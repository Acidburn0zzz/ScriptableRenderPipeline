#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/MotionBlurCommon.hlsl"

#pragma kernel TileGenPass          GEN_PASS
#pragma kernel TileNeighbourhood    NEIGHBOURHOOD_PASS

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#define USE_WAVE_INTRINSICS   0

#ifdef SUPPORTS_WAVE_INTRINSICS
groupshared float2 gs_minVel[((TILE_SIZE * TILE_SIZE) / WAVE_SIZE) + 1];
groupshared float2 gs_maxVel[((TILE_SIZE * TILE_SIZE) / WAVE_SIZE) + 1];


uint PackVelLengthAndLaneID(float len, uint ID)
{
	uint retVal = asuint(len) << 24;
	return retVal | ID;	
}

uint GetIDFromPacked(uint val)
{
	return val | 0xf;
}


#else
groupshared float2 gs_minVel[((TILE_SIZE * TILE_SIZE))];
groupshared float2 gs_maxVel[((TILE_SIZE * TILE_SIZE))];

#endif

// TODO_FCC: Do dispatch indirect for the fast pass. 

#ifdef GEN_PASS 
[numthreads(TILE_SIZE, TILE_SIZE,1)]
void TileGenPass(uint3 id : SV_DispatchThreadID, uint gid : SV_GroupIndex, uint2 groupThreadId : SV_GroupThreadID, uint3 groupID: SV_GroupID)
{
//
//    // This works only with multiple of 8 for TILE_SIZE. Also, not faster. TODO_FCC:  Verify if we can make it faster. Probably not.
#if defined(SUPPORTS_WAVE_INTRINSICS) && (USE_WAVE_INTRINSICS)
    uint waveCount = ((TILE_SIZE * TILE_SIZE) / WAVE_SIZE) + 1;

	// This is a bit clunky... over complicated, but I am now curious.

	float2 vel = LOAD_TEXTURE2D(_VelocityAndDepth, id.xy).xy;
	uint laneIdx = WaveGetLaneIndex();
	uint PackedVelID = PackVelLengthAndLaneID(vel.x, laneIdx);

	uint waveVelMin = WaveActiveMin(PackedVelID);
	uint waveVelMax = WaveActiveMax(PackedVelID);

	uint waveMinID = GetIDFromPacked(waveVelMin);
	uint waveMaxID = GetIDFromPacked(waveVelMax);

	// Only one per wave guaranteed. 
	uint waveIDInGroup = gid / WAVE_SIZE;
	if (waveMinID == laneIdx)
	{
		gs_minVel[waveIDInGroup] = vel;
	}
	if (waveMaxID == laneIdx)
	{
		gs_maxVel[waveIDInGroup] = vel;
	}


	// We have values for all the waves, let's sync. 
	GroupMemoryBarrierWithGroupSync();

	// Reduction across waves.
	// TODO_FCC Verify this is all scalar.
	float2 minVel = (gs_minVel[0]);
	float2 maxVel = (gs_maxVel[0]);
	for (int i = 1; i < waveCount; ++i)
	{
		minVel = MinVel(minVel, gs_minVel[i]);
        maxVel = MaxVel (maxVel, gs_maxVel[i]);
	}

    uint threadIdx = groupThreadId.y * TILE_SIZE + groupThreadId.x;
    float minVelLengthSq = dot(minVel, minVel);

    maxVel = maxVel;
    if (threadIdx == 0)
    {
        _TileMinMaxVel[groupID.xy] = float3(maxVel.x, maxVel.y, minVelLengthSq);
    }
#else
    uint threadIdx = groupThreadId.y * TILE_SIZE + groupThreadId.x;

    // TODO_FCC put this parallel reduction in a postprocess common file.
    float2 vel = LOAD_TEXTURE2D(_VelocityAndDepth, id.xy).xy;

    gs_minVel[threadIdx] = vel;
    gs_maxVel[threadIdx] = vel;

    GroupMemoryBarrierWithGroupSync();

    // Parallel reduction - find the max/min value for this tile
    UNITY_UNROLL
    for (uint s = (TILE_SIZE * TILE_SIZE) / 2u; s > 0u; s >>= 1u)
    {
        if (threadIdx < s)
        {
            gs_minVel[threadIdx] = MinVel(gs_minVel[threadIdx], gs_minVel[threadIdx + s]);
            gs_maxVel[threadIdx] = MaxVel(gs_maxVel[threadIdx], gs_maxVel[threadIdx + s]);
        }

        GroupMemoryBarrierWithGroupSync();
    }

    float2 minVel = gs_minVel[0];
    float2 maxVel = gs_maxVel[0];

    if (threadIdx == 0)
    {
        _TileMinMaxVel[groupID.xy] = float3(maxVel.x, maxVel.y, VelocityLengthFromEncoded(minVel));
    }
#endif

}

#elif NEIGHBOURHOOD_PASS 

[numthreads(8, 8, 1)]
void TileNeighbourhood(uint3 id : SV_DispatchThreadID, uint gid : SV_GroupIndex, uint2 groupThreadId : SV_GroupThreadID, uint3 groupID : SV_GroupID)
{
    // Sample the 1-ring neighbourhood of tile texture
    float3 centralSample = _TileMinMaxVel[id.xy + uint2( 0,  0)].xyz;
    float2 v0       = _TileMinMaxVel[id.xy + uint2(-1,  1)].xy;
    float2 v1       = _TileMinMaxVel[id.xy + uint2( 0,  1)].xy;
    float2 v2       = _TileMinMaxVel[id.xy + uint2( 1,  1)].xy;

    float2 v3       = _TileMinMaxVel[id.xy + uint2(-1,  0)].xy;
    float2 v4       = centralSample.xy;
    float2 v5       = _TileMinMaxVel[id.xy + uint2( 1,  0)].xy;

    float2 v6       = _TileMinMaxVel[id.xy + uint2(-1, -1)].xy;
    float2 v7       = _TileMinMaxVel[id.xy + uint2( 0, -1)].xy;
    float2 v8       = _TileMinMaxVel[id.xy + uint2( 1, -1)].xy;

    // TODO_FCC Can we use Max3 somehow? 
    float2 maxVel0 = MaxVel(v0, MaxVel(v1, v2));
    float2 maxVel1 = MaxVel(v3, MaxVel(v4, v5));
    float2 maxVel2 = MaxVel(v6, MaxVel(v7, v8));

    _TileMaxNeighbourhood[id.xy] = float4(MaxVel(maxVel0, MaxVel(maxVel1, maxVel2)), centralSample.z, 0) ;
}

#endif
