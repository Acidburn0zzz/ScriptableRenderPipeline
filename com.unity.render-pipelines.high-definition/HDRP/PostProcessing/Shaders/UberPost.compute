#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "CoreRP/ShaderLibrary/Color.hlsl"
#include "../../ShaderVariables.hlsl"
#include "UberPostFeatures.cs.hlsl"

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel KMain_Variant0 MAIN=KMain_Variant0 VARIANT=0
#pragma kernel KMain_Variant1 MAIN=KMain_Variant1 VARIANT=1
#pragma kernel KMain_Variant2 MAIN=KMain_Variant2 VARIANT=2
#pragma kernel KMain_Variant3 MAIN=KMain_Variant3 VARIANT=3
#pragma kernel KMain_Variant4 MAIN=KMain_Variant4 VARIANT=4
#pragma kernel KMain_Variant5 MAIN=KMain_Variant5 VARIANT=5
#pragma kernel KMain_Variant6 MAIN=KMain_Variant6 VARIANT=6
#pragma kernel KMain_Variant7 MAIN=KMain_Variant7 VARIANT=7

TEXTURE2D(_InputTexture);
TEXTURE2D(_ChromaSpectralLut);
TEXTURE3D(_LogLut3D);
TEXTURE2D(_VignetteMask);

RW_TEXTURE2D(float4, _OutputTexture);

SAMPLER(sampler_LinearClamp);
SAMPLER(sampler_ChromaSpectralLut);
SAMPLER(sampler_LogLut3D);
SAMPLER(sampler_VignetteMask);

CBUFFER_START(cb0)
    float4 _ChromaParams;           // x: amount, y: max samples, zw: unused
    float4 _VignetteParams1;        // xy: center, z: mode, w: unused
    float4 _VignetteParams2;        // x: intensity, y: smoothness, z: roundness, w: rounded
    float4 _VignetteColor;          // xyz: color, w: opacity
    float4 _DistortionParams1;      // xy: center, zw: axis intensity
    float4 _DistortionParams2;      // x: theta, y: sigma, z: scale, w: intensity
    float4 _LogLut3D_Params;        // x: 1 / lut_size, y: lut_size - 1, z: postexposure, w: unused
CBUFFER_END

float2 DistortUV(float2 uv)
{
    // Lens distortion
    // Note: this variant should never be set with XR
    if (VARIANT & UBERPOSTFEATUREFLAGS_LENS_DISTORTION)
    {
        const float2 center = _DistortionParams1.xy;
        const float2 axisIntensity = _DistortionParams1.zw;
        const float theta = _DistortionParams2.x;
        const float sigma = _DistortionParams2.y;
        const float scale = _DistortionParams2.z;
        const float intensity = _DistortionParams2.w;

        uv = (uv - 0.5) * scale + 0.5;
        float2 ruv = axisIntensity * (uv - 0.5 - center);
        float ru = length(float2(ruv));

        UNITY_BRANCH
        if (intensity > 0.0)
        {
            float wu = ru * theta;
            ru = tan(wu) * (rcp(ru * sigma));
            uv = uv + ruv * (ru - 1.0);
        }
        else
        {
            ru = rcp(ru) * theta * atan(ru * sigma);
            uv = uv + ruv * (ru - 1.0);
        }
    }

    return uv;
}

[numthreads(8,8,1)]
void MAIN(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (any(dispatchThreadId > uint2(_ScreenSize.xy)))
        return; // Out of bounds, discard

    PositionInputs posInputs = GetPositionInput(float2(dispatchThreadId), _ScreenSize.zw, uint2(8u, 8u));
    float2 uv = posInputs.positionNDC;
    float2 uvDistorted = DistortUV(uv);
    float4 color = 0.0;

    // Chromatic aberration    
    // Inspired by the method described in "Rendering Inside" [Playdead 2016]
    // https://twitter.com/pixelmager/status/717019757766123520
    if (VARIANT & UBERPOSTFEATUREFLAGS_CHROMATIC_ABERRATION)
    {
        const float amount = _ChromaParams.x;
        const int maxSamples = int(_ChromaParams.y);

        float2 coords = 2.0 * uv - 1.0;
        float2 end = uv - coords * dot(coords, coords) * amount;
        float2 diff = end - uv;
        int samples = clamp(int(length(_ScreenSize.xy * diff / 2.0)), 3, maxSamples);
        float2 delta = diff / samples;
        float2 pos = uv;
        float4 sum = 0.0, filterSum = 0.0;

        for (int i = 0; i < samples; i++)
        {
            float t = (i + 0.5) / samples;
            float4 s = SAMPLE_TEXTURE2D_LOD(_InputTexture, sampler_LinearClamp, DistortUV(pos) * _ScreenToTargetScale.xy, 0);
            float4 filter = float4(SAMPLE_TEXTURE2D_LOD(_ChromaSpectralLut, sampler_ChromaSpectralLut, float2(t, 0.0), 0).rgb, 1.0);

            sum += s * filter;
            filterSum += filter;
            pos += delta;
        }

        color = sum / filterSum;
    }
    else
    {
        color = SAMPLE_TEXTURE2D_LOD(_InputTexture, sampler_LinearClamp, uvDistorted * _ScreenToTargetScale.xy, 0);
    }

    // Vignette
    if (VARIANT & UBERPOSTFEATUREFLAGS_VIGNETTE)
    {
        const uint mode = _VignetteParams1.z;

        UNITY_BRANCH
        if (mode == 0u) // Procedural
        {
            const float2 center = _VignetteParams1.xy;
            const float intensity = _VignetteParams2.x;
            const float smoothness = _VignetteParams2.y;
            const float roundness = _VignetteParams2.z;
            const float rounded = _VignetteParams2.w;

            float2 d = abs(uvDistorted - center) * intensity;
            d.x *= lerp(1.0, _ScreenSize.x / _ScreenSize.y, rounded);
            d = pow(saturate(d), roundness);
            float vfactor = pow(saturate(1.0 - dot(d, d)),smoothness);
            color.rgb *= lerp(_VignetteColor.xyz, (1.0).xxx, vfactor);
            color.a = lerp(1.0, color.a, vfactor);
        }
        else // Masked
        {
            float vfactor = SAMPLE_TEXTURE2D_LOD(_VignetteMask, sampler_VignetteMask, uvDistorted, 0).a;
            vfactor = FastSRGBToLinear(vfactor);
            float3 newColor = color.rgb * lerp(_VignetteColor.xyz, (1.0).xxx, vfactor);
            color.rgb = lerp(color.rgb, newColor, _VignetteColor.a);
            color.a = lerp(1.0, color.a, vfactor);
        }
    }

    // Grading, tonemapping, ODT
    // This is always on when post-processing is enabled as ODTs will be baked into the grading LUT
    {
        color *= _LogLut3D_Params.z;
        float3 colorLutSpace = saturate(LinearToLogC(color.rgb));
        color.rgb = ApplyLut3D(TEXTURE3D_PARAM(_LogLut3D, sampler_LogLut3D), colorLutSpace, _LogLut3D_Params.xy);
    }

    // Done
    _OutputTexture[posInputs.positionSS] = color;
}
